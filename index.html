<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sax Note Guess — Pro (single file)</title>
<style>
  :root{
    --bg:#071227; --card:#0b1430; --muted:#9fb0c8; --accent:#ffb86b; --good:#66e3a6; --bad:#ff7b7b;
    --panel-gap:14px; --radius:12px; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:#eaf4ff;
  }
  html,body{height:100%;}
  body{margin:0;padding:18px; background:linear-gradient(180deg,#041022,#071630); display:flex; justify-content:center; align-items:flex-start; min-height:100vh;}
  .wrap{width:1100px; max-width:98%; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); border-radius:var(--radius); padding:18px; box-shadow:0 22px 60px rgba(0,0,0,.6);}
  header{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;}
  h1{font-size:20px;margin:0;}
  .muted{color:var(--muted); font-size:13px;}
  .grid{display:flex; gap:var(--panel-gap); align-items:flex-start;}
  .left{flex:1; min-width:320px;}
  .right{width:360px;}
  .card{background:var(--card); border-radius:10px; padding:14px; margin-bottom:12px;}
  .big-note{font-size:48px; font-weight:700; margin:8px 0;}
  .controls-row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  select,input[type=range],button,input[type=checkbox]{background:#071226;color:inherit;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;}
  .buttons{display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-top:12px;}
  .choice{padding:12px;border-radius:9px;border:1px solid rgba(255,255,255,0.04);background:transparent;font-weight:600;cursor:pointer;min-height:48px; display:flex; align-items:center; justify-content:center; font-size:16px;}
  .choice.correct{background:linear-gradient(90deg,#003d2f,#075b46); color:var(--good); border-color:rgba(110,231,183,0.12);}
  .choice.wrong{background:linear-gradient(90deg,#3b0f0f,#591010); color:var(--bad); border-color:rgba(255,123,123,0.12);}
  .playbtn{background:linear-gradient(90deg,var(--accent), #ff9a6b); color:#06121a; border:none; padding:12px 16px; border-radius:10px; font-weight:700; cursor:pointer;}
  .row{display:flex; gap:8px; align-items:center;}
  .kbd{background:#071226;border-radius:6px;padding:6px 8px;font-size:13px;}
  .small{font-size:13px;}
  footer{font-size:12px;color:var(--muted); margin-top:8px;}
  /* responsive */
  @media (max-width:900px){
    .grid{flex-direction:column;}
    .right{width:100%;}
    .buttons{grid-template-columns: repeat(2, 1fr);}
    .big-note{font-size:40px;}
    .choice{min-height:56px;font-size:18px;}
  }
  /* mobile sticky play */
  @media (max-width:520px){
    .sticky-play{position:fixed; left:12px; right:12px; bottom:12px; z-index:60;}
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Sax note guessing trainer">
    <header>
      <div>
        <h1>Sax Note Guess — Pro</h1>
        <div class="muted small">Practice transposed notes, realistic synth, adaptive difficulty — mobile friendly</div>
      </div>
      <div class="controls-row">
        <label class="muted small">Mode
          <select id="gameMode">
            <option value="practice">Practice</option>
            <option value="timed">60s Timed</option>
            <option value="survival">Survival (3 wrong)</option>
          </select>
        </label>
        <label class="muted small">Auto-Advance
          <select id="autoAdvance">
            <option value="off">Off</option>
            <option value="correct">On correct</option>
            <option value="always">Always</option>
          </select>
        </label>
      </div>
    </header>

    <div class="grid">
      <main class="left">
        <div class="card" id="mainCard">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
            <div>
              <div class="muted small">Identify this note</div>
              <div id="displayNote" class="big-note" aria-live="polite">???</div>
              <div id="subInfo" class="muted small">Press <span class="kbd">Space</span> or Play to hear the pitch. Replay freely.</div>
            </div>
            <div style="text-align:right;min-width:140px">
              <div class="muted small">Score</div>
              <div id="score" style="font-weight:700;font-size:18px">0 / 0</div>
              <div id="streak" class="muted small">Streak: 0</div>
            </div>
          </div>

          <div id="choicesArea" class="buttons" style="margin-top:12px">
            <!-- choices injected here -->
          </div>

          <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;">
            <button id="play" class="playbtn">Play ▶</button>
            <button id="replay">Play Again ↺</button>
            <button id="next">Next »</button>
            <label style="align-items:center;display:flex;gap:6px;"><input id="vibrate" type="checkbox" /> Haptics</label>
            <label style="align-items:center;display:flex;gap:6px;"><input id="autoRepCorrect" type="checkbox" /> Replay correct after guess</label>
          </div>

          <div id="resultHint" class="muted small" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <div class="controls-row" style="justify-content:flex-start;">
            <label class="muted small">Difficulty
              <select id="difficulty">
                <option value="scale">Scale (major)</option>
                <option value="chromatic">Chromatic</option>
              </select>
            </label>

            <label class="muted small">Root Key
              <select id="rootKey"></select>
            </label>

            <label class="muted small">Range
              <select id="range">
                <option value="C3-C5">C3 — C5</option>
                <option value="C4-C6" selected>C4 — C6</option>
                <option value="A2-A4">A2 — A4</option>
                <option value="A3-A5">A3 — A5</option>
              </select>
            </label>
          </div>

          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;">
            <label class="muted small"><input id="octaveHidden" type="checkbox" /> Octave hidden</label>
            <label class="muted small"><input id="requireOctave" type="checkbox" /> Force octave in choices</label>
            <label class="muted small">Accidentals
              <select id="accidentalOpt">
                <option value="auto">Auto by key</option>
                <option value="sharp">Sharps</option>
                <option value="flat">Flats</option>
              </select>
            </label>
          </div>
        </div>

        <div class="card">
          <div class="controls-row">
            <div>
              <div class="muted small">Transpose / Instrument</div>
              <select id="preset">
                <option value="concert">Concert (C)</option>
                <option value="alto_eb">Alto Sax (E♭) — written -> sounding -9</option>
                <option value="bari_eb">Baritone Sax (E♭) — written -> sounding -21</option>
                <option value="tenor_bb">Tenor Sax (B♭) — written -> sounding -14</option>
                <option value="soprano_bb">Soprano Sax (B♭) — written -> sounding -2</option>
                <option value="custom">Custom</option>
              </select>
            </div>

            <div id="customShiftWrap" style="display:none;">
              <div class="muted small">Custom shift (semitones)</div>
              <input id="customShift" type="number" value="0" style="width:110px" />
            </div>

            <div>
              <div class="muted small">Game difficulty adapt</div>
              <select id="adaptive">
                <option value="off">Adaptive OFF</option>
                <option value="gentle">Adaptive ON — Gentle</option>
                <option value="aggressive">Adaptive ON — Aggressive</option>
              </select>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="muted small">Audio profile</div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap;">
            <select id="audioProfile">
              <option value="clean">Clean Sax</option>
              <option value="breathy">Breathy / Soft</option>
              <option value="bright">Bright / Edge</option>
              <option value="muted">Muted / Subtone</option>
            </select>
            <label class="muted small"><input id="vibrato" type="checkbox" checked /> Vibrato</label>
            <label class="muted small">Volume <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6" /></label>
          </div>
        </div>

      </main>

      <aside class="right">
        <div class="card">
          <div class="muted small">Stats</div>
          <div style="margin-top:8px;">
            <div class="row"><div class="muted small">Accuracy</div><div style="flex:1"></div><div id="statAccuracy" class="muted small">—</div></div>
            <div class="row"><div class="muted small">Avg rt</div><div style="flex:1"></div><div id="statAvg" class="muted small">—</div></div>
            <div class="row"><div class="muted small">Best streak</div><div style="flex:1"></div><div id="statBest" class="muted small">0</div></div>
            <div class="row"><div class="muted small">Total</div><div style="flex:1"></div><div id="statTotal" class="muted small">0</div></div>
            <div style="margin-top:8px;"><button id="resetStats">Reset Stats</button></div>
          </div>
        </div>

        <div class="card">
          <div class="muted small">Missed notes (top)</div>
          <ol id="missedList" class="muted small" style="margin-top:8px"></ol>
        </div>

        <div class="card">
          <div class="muted small">Game tips</div>
          <ul class="muted small" style="margin-top:8px">
            <li>Use octave-hidden to train pitch class recognition.</li>
            <li>Adaptive difficulty adjusts range/chromatic content automatically.</li>
            <li>Use Play Again before Next to replay the same note.</li>
          </ul>
        </div>
      </aside>
    </div>

    <footer class="muted small">If you'd like I can add real recorded samples uploader next — this version keeps everything synthesized and offline.</footer>
  </div>

<script>
/* ====================
   Utilities: notes / midi / names
   ==================== */
const SHARP = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const FLAT  = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
const A4_MIDI = 69, A4_FREQ = 440;

function midiToFreq(m){ return A4_FREQ * Math.pow(2,(m - A4_MIDI)/12); }
function midiPc(m, useFlats=false){ const i=((m%12)+12)%12; return useFlats ? FLAT[i] : SHARP[i]; }
function midiName(m, useFlats=false){ const i=((m%12)+12)%12; const oct = Math.floor(m/12)-1; return (useFlats?FLAT[i]:SHARP[i]) + oct; }
function nameToMidi(name){
  const match = name.match(/^([A-G][b#]?)(-?\d+)$/i);
  if(!match) return null;
  const pitch = match[1].toUpperCase();
  const oct = parseInt(match[2],10);
  const idx = SHARP.indexOf(pitch) !== -1 ? SHARP.indexOf(pitch) : FLAT.indexOf(pitch);
  if(idx < 0) return null;
  return (oct + 1)*12 + idx;
}
function parseRange(r){
  const [a,b]=r.split('-'); return [nameToMidi(a), nameToMidi(b)];
}

/* ========= DOM refs ========= */
const playBtn = document.getElementById('play'), replayBtn = document.getElementById('replay'), nextBtn = document.getElementById('next');
const choicesArea = document.getElementById('choicesArea'), displayNote = document.getElementById('displayNote');
const resultHint = document.getElementById('resultHint'), scoreEl = document.getElementById('score'), streakEl = document.getElementById('streak');
const difficultySel = document.getElementById('difficulty'), rootKeySel = document.getElementById('rootKey'), rangeSel = document.getElementById('range');
const octaveHiddenChk = document.getElementById('octaveHidden'), requireOctaveChk = document.getElementById('requireOctave');
const accidentalOpt = document.getElementById('accidentalOpt'), accidentalDisplayChk = document.getElementById('accidentalDisplay'); // accidentalDisplayChk may not exist
const presetSel = document.getElementById('preset'), customShiftWrap = document.getElementById('customShiftWrap'), customShiftInput = document.getElementById('customShift');
const adaptiveSel = document.getElementById('adaptive');
const audioProfileSel = document.getElementById('audioProfile'), vibratoChk = document.getElementById('vibrato'), volumeEl = document.getElementById('volume');
const autoAdvanceSel = document.getElementById('autoAdvance'), autoRepCorrect = document.getElementById('autoRepCorrect');
const audioVibrateChk = document.getElementById('vibrate');
const gameModeSel = document.getElementById('gameMode');
const statAccuracy = document.getElementById('statAccuracy'), statAvg = document.getElementById('statAvg'), statBest = document.getElementById('statBest'), statTotal = document.getElementById('statTotal');
const missedList = document.getElementById('missedList'), resetStatsBtn = document.getElementById('resetStats');

/* ========= State ========= */
let audioCtx = null, masterGain = null;
let current = { writtenMidi:null, soundingMidi:null, tStart:0 };
let stats = { total:0, correct:0, totalResponseMs:0, bestStreak:0, currentStreak:0, misses:{} };
let gameTimer = null, timeLeft = 0, survivalLeft = 3;

/* Presets: shift (written -> sounding) */
const PRESETS = { concert:0, alto_eb:-9, bari_eb:-21, tenor_bb:-14, soprano_bb:-2, custom:0 };

/* Fill root key select */
(function fillRoots(){
  for(let i=0;i<12;i++){
    const opt = document.createElement('option'); opt.value = i; opt.textContent = SHARP[i] + ' / ' + FLAT[i];
    rootKeySel.appendChild(opt);
  }
})();

/* Load stats from localStorage */
function loadStats(){
  try{ const s = localStorage.getItem('sax_trainer_stats_v2'); if(s) stats = JSON.parse(s); } catch(e){}
  updateStatsUI();
}
function saveStats(){ try{ localStorage.setItem('sax_trainer_stats_v2', JSON.stringify(stats)); }catch(e){} updateStatsUI(); }
function resetStats(){ stats={ total:0, correct:0, totalResponseMs:0, bestStreak:0, currentStreak:0, misses:{} }; saveStats(); }
resetStatsBtn.addEventListener('click', ()=> { if(confirm('Reset stats?')) resetStats(); });

/* Adaptive difficulty logic */
function adaptiveTune(){
  const mode = adaptiveSel.value;
  if(mode === 'off') return;
  const acc = stats.total ? (stats.correct / stats.total) : 1.0;
  // Gentle vs aggressive
  if(mode === 'gentle'){
    if(acc > 0.85) {
      // widen by selecting bigger range if possible — choose higher range preset
      if(rangeSel.value === 'C4-C6') rangeSel.value = 'A3-A5';
      else if(rangeSel.value === 'C3-C5') rangeSel.value = 'C4-C6';
    } else if(acc < 0.6){
      // narrow
      if(rangeSel.value === 'A3-A5') rangeSel.value = 'C4-C6';
      else if(rangeSel.value === 'C4-C6') rangeSel.value = 'C3-C5';
    }
  } else if(mode === 'aggressive'){
    if(acc > 0.85){
      rangeSel.value = 'A3-A5';
      difficultySel.value = 'chromatic';
    } else if(acc < 0.6){
      rangeSel.value = 'C3-C5';
      difficultySel.value = 'scale';
    }
  }
}

/* Build question: choose writtenMidi (display), compute sounding using preset shift */
function pickNewWritten(){
  const [low,high] = parseRange(rangeSel.value);
  const rootPc = parseInt(rootKeySel.value,10);
  const difficulty = difficultySel.value;
  const preset = presetSel.value;
  // build pool based on difficulty
  let pool = [];
  if(difficulty === 'scale'){
    const degrees = [0,2,4,5,7,9,11];
    for(let m=low;m<=high;m++){
      const pc = ((m%12)+12)%12;
      const interval = (pc - rootPc + 12) % 12;
      if(degrees.includes(interval)) pool.push(m);
    }
    if(pool.length === 0) for(let m=low;m<=high;m++) pool.push(m);
  } else {
    for(let m=low;m<=high;m++) pool.push(m);
  }
  return pool[Math.floor(Math.random()*pool.length)];
}

/* Utility: format label according to octaveHidden/requireOctave/accidental options */
function getDisplayLabel(midi){
  const accOpt = accidentalOpt.value; // auto/sharp/flat
  let useFlats = false;
  if(accOpt === 'sharp') useFlats = false;
  else if(accOpt === 'flat') useFlats = true;
  else {
    // auto: if root key uses flats, show flats (very simple logic)
    const root = parseInt(rootKeySel.value,10);
    const flatKeys = [1,3,6,8,10]; // simplistic: Db, Eb, Gb, Ab, Bb (not strictly accurate for key signatures but fine)
    useFlats = flatKeys.includes(root);
  }
  if(octaveHiddenChk.checked) return midiPc(midi, useFlats);
  if(requireOctaveChk.checked) return midiName(midi, useFlats);
  // Default: show name+octave but can hide octave for compact ranges — we'll show name+octave for clarity
  return midiName(midi, useFlats);
}

/* Build unique choices based on labels (ensures no duplicate labels) */
function buildUniqueChoices(correctWritten){
  const [low,high] = parseRange(rangeSel.value);
  const needed = 8;
  const rawCandidates = [];
  // make a candidate set depending on difficulty
  if(difficultySel.value === 'scale'){
    const rootPc = parseInt(rootKeySel.value,10);
    const degrees = [0,2,4,5,7,9,11];
    for(let m=low;m<=high;m++){
      const pc = ((m%12)+12)%12;
      if(degrees.includes((pc - rootPc + 12) % 12)) rawCandidates.push(m);
    }
  } else {
    for(let m=low;m<=high;m++) rawCandidates.push(m);
  }
  // ensure rawCandidates contains correctWritten
  if(!rawCandidates.includes(correctWritten)) rawCandidates.push(correctWritten);

  // we will create label->midi mapping to dedupe labels
  const labelToMidi = new Map();
  function tryAdd(m){
    const label = getDisplayLabel(m);
    if(!labelToMidi.has(label)) labelToMidi.set(label, m);
    // if label exists but maps to a different midi, we keep first occurrence to avoid duplicates
  }

  // add correct first
  tryAdd(correctWritten);

  // prefer near notes as distractors first
  const spread = Math.max(2, Math.floor((high-low)/10));
  const candSet = new Set(rawCandidates);
  // add near offsets
  for(let off=1; off<=spread*2 && labelToMidi.size < needed; off++){
    [off, -off].forEach(o=>{
      const m = correctWritten + o;
      if(m >= low && m <= high) tryAdd(m);
    });
  }
  // fill from pool randomly
  const shuffled = Array.from(candSet).sort(()=>Math.random()-0.5);
  for(const m of shuffled){
    if(labelToMidi.size >= needed) break;
    tryAdd(m);
  }
  // if still short, expand by octave shifts
  let octaveShift = 12;
  while(labelToMidi.size < needed){
    const mUp = correctWritten + octaveShift;
    const mDn = correctWritten - octaveShift;
    if(mUp >= low && mUp <= high) tryAdd(mUp);
    if(mDn >= low && mDn <= high) tryAdd(mDn);
    octaveShift += 12;
    if(octaveShift > 48) break;
  }

  // ensure correct label present
  const correctLabel = getDisplayLabel(correctWritten);
  if(!labelToMidi.has(correctLabel)) labelToMidi.set(correctLabel, correctWritten);

  // Turn into array and shuffle
  const entries = Array.from(labelToMidi.entries()).slice(0, needed);
  for(let i=entries.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [entries[i],entries[j]]=[entries[j],entries[i]]; }
  // return array of {label, midi}
  return entries.map(([label,midi])=>({label,midi}));
}

/* New question: picks written, computes sounding, renders choices, optionally plays */
function newQuestion(skipPlay=false){
  if(!audioCtx) createAudio();
  resultHint.textContent = '';
  displayNote.textContent = '???';
  // pick written based on difficulty & range
  const written = pickNewWritten();
  // compute sounding using preset
  const preset = presetSel.value;
  const shift = (preset === 'custom') ? parseInt(customShiftInput.value||'0',10) : PRESETS[preset];
  const sounding = written + shift;
  current.writtenMidi = written; current.soundingMidi = sounding; current.tStart = performance.now();
  // render choices
  renderChoicesFor(written);
  // play unless specified not to
  if(!skipPlay) playCurrent();
}

/* Render choices for a given written midi */
function renderChoicesFor(writtenMidi){
  choicesArea.innerHTML = '';
  const arr = buildUniqueChoices(writtenMidi);
  arr.forEach((item, idx)=>{
    const btn = document.createElement('button');
    btn.className = 'choice';
    btn.textContent = item.label;
    btn.dataset.written = item.midi;
    btn.dataset.index = idx;
    btn.addEventListener('click', onChoose);
    choicesArea.appendChild(btn);
  });
}

/* Answer handling */
function onChoose(e){
  const btn = e.currentTarget;
  const chosen = parseInt(btn.dataset.written,10);
  const correct = current.writtenMidi;
  const now = performance.now();
  const rt = now - current.tStart;
  // update stats
  stats.total = (stats.total||0) + 1;
  if(chosen === correct){
    stats.correct = (stats.correct||0) + 1;
    stats.currentStreak = (stats.currentStreak||0) + 1;
    stats.bestStreak = Math.max(stats.bestStreak||0, stats.currentStreak);
    btn.classList.add('correct');
    resultHint.textContent = 'Correct — sounded: ' + midiName(current.soundingMidi, shouldUseFlats());
    if(autoRepCorrect.checked){
      setTimeout(()=>playCurrent(), 160);
    }
    if(autoAdvanceSel.value === 'correct' || autoAdvanceSel.value === 'always'){
      setTimeout(()=> {
        newQuestion();
      }, 600);
    }
    // vibrate small
    if(audioVibrateChk.checked && navigator.vibrate) navigator.vibrate(40);
    // record response time
    stats.totalResponseMs = (stats.totalResponseMs||0) + rt;
  } else {
    stats.currentStreak = 0;
    btn.classList.add('wrong');
    // reveal correct button visually
    Array.from(choicesArea.children).forEach(b=>{ if(parseInt(b.dataset.written,10) === correct) b.classList.add('correct'); });
    resultHint.textContent = 'Incorrect — sounded: ' + midiName(current.soundingMidi, shouldUseFlats());
    // record miss
    const pc = midiPc(correct, shouldUseFlats());
    stats.misses[pc] = (stats.misses[pc]||0) + 1;
    if(audioVibrateChk.checked && navigator.vibrate) navigator.vibrate([40,20,30]);
    // survival mode handling
    if(gameModeSel.value === 'survival'){
      survivalLeft -= 1;
      if(survivalLeft <= 0){
        resultHint.textContent += ' — Game over (survival). Press Next to restart.';
      }
    }
  }
  // disable choices
  Array.from(choicesArea.children).forEach(b=>b.disabled = true);
  // reveal displayed written note (respect octaveHidden option: show appropriate form)
  const displayLabel = octaveHiddenChk.checked ? midiPc(current.writtenMidi, shouldUseFlats()) : midiName(current.writtenMidi, shouldUseFlats());
  displayNote.textContent = displayLabel;
  // update stats & UI
  saveStats();
  updateStatsUI();
}

/* ========== UI Stats update ========== */
function updateStatsUI(){
  scoreEl.textContent = (stats.correct||0) + ' / ' + (stats.total||0);
  streakEl.textContent = 'Streak: ' + (stats.currentStreak||0);
  statAccuracy.textContent = stats.total ? Math.round((stats.correct/stats.total)*100) + '%' : '—';
  statAvg.textContent = stats.totalResponseMs ? Math.round(stats.totalResponseMs / stats.total) + ' ms' : '—';
  statBest.textContent = stats.bestStreak || 0;
  statTotal.textContent = stats.total || 0;
  // missed list
  missedList.innerHTML = '';
  const arr = Object.entries(stats.misses || {});
  arr.sort((a,b)=>b[1]-a[1]);
  arr.slice(0,8).forEach(([note,count])=>{
    const li = document.createElement('li'); li.textContent = `${note} — ${count}`; missedList.appendChild(li);
  });
}

/* ========== Audio: Improved sax-like synth with profiles ========== */
function createAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(volumeEl.value || 0.6);
  masterGain.connect(audioCtx.destination);
}

/* Choose if we should use flats for labels (simple logic) */
function shouldUseFlats(){
  const opt = accidentalOpt.value;
  if(opt === 'flat') return true;
  if(opt === 'sharp') return false;
  // auto
  const root = parseInt(rootKeySel.value,10);
  const flatKeys = [1,3,6,8,10];
  return flatKeys.includes(root);
}

/* Play a single note (sounding MIDI) */
function playCurrent(){
  if(!current.soundingMidi) return;
  if(!audioCtx) createAudio();
  if(audioCtx.state === 'suspended') audioCtx.resume();
  masterGain.gain.value = parseFloat(volumeEl.value || 0.6);

  const freq = midiToFreq(current.soundingMidi);
  playSaxLike(freq);
}

/* Sax synth: uses two oscillators, formant peaking, noise, mild vibrato and profile adjustments */
function playSaxLike(freq){
  if(!audioCtx) createAudio();
  const now = audioCtx.currentTime + 0.01;
  const dur = 1.2 + Math.random()*0.8;

  // envelope
  const env = audioCtx.createGain();
  env.gain.setValueAtTime(0.0001, now);
  env.gain.linearRampToValueAtTime(1.0, now + 0.02);
  env.gain.exponentialRampToValueAtTime(0.15, now + 0.55);
  env.gain.exponentialRampToValueAtTime(0.001, now + dur);
  env.connect(masterGain);

  // base oscillators (triangle + saw/pulse blend)
  const o1 = audioCtx.createOscillator(); o1.type = 'triangle';
  const o2 = audioCtx.createOscillator(); o2.type = 'sawtooth';
  // slight detune
  const detune = (Math.random()*6 - 3);
  o1.frequency.value = freq * (1 + (Math.random()*0.002 - 0.001));
  o2.frequency.value = freq * (1 + (detune/1000));
  // mix
  const mix = audioCtx.createGain(); mix.gain.value = 0.9;
  o1.connect(mix); o2.connect(mix);

  // vibrato LFO (user toggle)
  let vibOsc, vibGain;
  if(vibratoChk.checked){
    vibOsc = audioCtx.createOscillator(); vibOsc.type='sine'; vibOsc.frequency.value=5 + Math.random()*2;
    vibGain = audioCtx.createGain(); vibGain.gain.value = freq * 0.0015; // subtle
    vibOsc.connect(vibGain); vibGain.connect(o1.frequency); vibGain.connect(o2.frequency);
    vibOsc.start(now);
  }

  // breath noise
  const bufSize = 2 * audioCtx.sampleRate;
  const noiseBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for(let i=0;i<bufSize;i++) data[i] = (Math.random()*2 - 1);
  const noiseSrc = audioCtx.createBufferSource(); noiseSrc.buffer = noiseBuf;
  const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type='bandpass';
  noiseFilter.frequency.value = Math.max(600, freq*0.8);
  noiseFilter.Q.value = 0.8;
  const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.06;
  noiseSrc.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(env);

  // formant peaking to shape sax-like tone (two peaks)
  const form1 = audioCtx.createBiquadFilter(); form1.type='peaking'; form1.frequency.value = Math.max(700, freq*1.6); form1.gain.value = 6; form1.Q.value = 1.2;
  const form2 = audioCtx.createBiquadFilter(); form2.type='peaking'; form2.frequency.value = Math.max(1200, freq*2.5); form2.gain.value = 4; form2.Q.value = 1.0;
  mix.connect(form1); form1.connect(form2); form2.connect(env);

  // final tone filter (gentle lowpass to avoid harshness)
  const toneFilter = audioCtx.createBiquadFilter(); toneFilter.type='lowpass';
  // profile adjustments
  const profile = audioProfileSel.value; // clean, breathy, bright, muted
  if(profile === 'clean'){ toneFilter.frequency.value = 6800; form1.gain.value = 6; noiseGain.gain.value = 0.06; }
  else if(profile === 'breathy'){ toneFilter.frequency.value = 5200; form1.gain.value = 4; noiseGain.gain.value = 0.12; env.gain.exponentialRampToValueAtTime(0.12, now + dur); }
  else if(profile === 'bright'){ toneFilter.frequency.value = 8800; form1.gain.value = 8; noiseGain.gain.value = 0.04; }
  else if(profile === 'muted'){ toneFilter.frequency.value = 4200; form1.gain.value = 3; noiseGain.gain.value = 0.02; }

  // connect through filter to env -> master
  // currently form2 -> env already done; but we want toneFilter before masterGain for global shape
  // so create an intermediate
  const finalGain = audioCtx.createGain(); finalGain.gain.value = 1.0;
  env.disconnect(masterGain);
  env.connect(toneFilter); toneFilter.connect(finalGain); finalGain.connect(masterGain);

  // start sources
  o1.start(now); o2.start(now); noiseSrc.start(now);
  // stop them later
  o1.stop(now + dur + 0.05); o2.stop(now + dur + 0.05); noiseSrc.stop(now + dur + 0.05);
  if(vibOsc) vibOsc.stop(now + dur + 0.05);
}

/* ========== Event wiring ========== */
playBtn.addEventListener('click', ()=> playCurrent());
replayBtn.addEventListener('click', ()=> playCurrent());
nextBtn.addEventListener('click', ()=> {
  if(gameModeSel.value === 'timed' && !gameTimer) startTimed();
  if(gameModeSel.value === 'survival') survivalLeft = 3;
  newQuestion();
  Array.from(choicesArea.children).forEach(b=>{ b.disabled = false; b.className='choice'; });
});

document.addEventListener('keydown', (ev)=>{
  if(ev.code === 'Space'){ ev.preventDefault(); playCurrent(); }
  else if(ev.key.toLowerCase() === 'n'){ newQuestion(); }
  else if(ev.key.toLowerCase() === 'r'){ resetStats(); }
  else {
    const k = parseInt(ev.key,10);
    if(!isNaN(k) && k >= 1){
      const btn = choicesArea.children[k-1];
      if(btn && !btn.disabled) btn.click();
    }
  }
});

/* Setting changes */
presetSel.addEventListener('change', ()=> {
  if(presetSel.value === 'custom') customShiftWrap.style.display = 'block'; else customShiftWrap.style.display = 'none';
});
adaptiveSel.addEventListener('change', ()=> { /* no-op */ });
audioProfileSel.addEventListener('change', ()=> { /* change will take effect at next play */ });
volumeEl.addEventListener('input', ()=> { if(masterGain) masterGain.gain.value = parseFloat(volumeEl.value); });

/* Timed mode */
function startTimed(){
  if(gameTimer) clearInterval(gameTimer);
  timeLeft = 60;
  const timerSpan = document.createElement('span'); timerSpan.id='timerSpan';
  const sub = document.getElementById('subInfo'); sub.appendChild(timerSpan);
  timerSpan.textContent = ' • Time: ' + timeLeft + 's';
  gameTimer = setInterval(()=>{
    timeLeft--;
    timerSpan.textContent = ' • Time: ' + timeLeft + 's';
    if(timeLeft <= 0){
      clearInterval(gameTimer); gameTimer = null; timerSpan.textContent = ' • Time: 0s — Done';
      resultHint.textContent = `Time's up! Score: ${stats.correct} / ${stats.total}`;
    }
  },1000);
}

/* ========== Initialization ========== */
function init(){
  // default root C
  rootKeySel.value = "0";
  presetSel.value = 'alto_eb';
  customShiftWrap.style.display = 'none';
  loadStats();
  newQuestion();
}
init();

/* Handle saving stats automatically and adaptive tuning after each question generation */
const origSaveStats = saveStats;
saveStats = function(){
  adaptiveTune();
  origSaveStats();
};

</script>
</body>
</html>
